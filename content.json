{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/12/17/hello-world/"},{"title":"the way to blog","text":"进行基本的配置12334 个性化234 插入图片","link":"/2021/12/18/the-way-to-blog/"},{"title":"char* p[6] vs char* p[6]的指针总结","text":"char*p[6] vs char (*p)[6]面对定义和声明我们总是要记住一点 分清类型和标识符 我们把上面分析一下 1char* [6] vs char (*)[6] 其中p 是标识符,于是char *[6]表示我有[6]个元素,他们是char * 类型char (*)[6]表示老子有括号,先注意括号,括号表明这个是指针,指向的是char[6] 练习 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main(){ char*(*p)[3]; char* a[3]; a[0] = &quot;colin&quot;; a[1] = &quot;ray&quot;; a[2] = &quot;joan&quot;; p = &amp;a; for (int i = 0; i &lt; 3; i++) { printf(&quot;p=%s\\n&quot;, (*p)[i]); } return 0;} 上面为什么成功? 解答 先把标识符拿开,于是有 char *(*)[3] 这下很好办了,p这是个指针,指向char*[3],及有三个char*元素的数组 *(p)里面是数组的首地址 这时*(p)[i]就能解释 参考 https://www.geeksforgeeks.org/difference-between-int-p3-and-int-p3/ https://stackoverflow.com/questions/18193983/what-is-difference-between-int-p3-and-int-p3","link":"/2021/12/18/pointer_sumary/"},{"title":"关于volatile","text":"参考教程:https://aticleworld.com/understanding-volatile-qualifier-in-c/ 搞清volatile,从以下几点出发 为什么有 怎么用 用在哪 怎么用好 为什么要有volatile这个关键词的本意就是容易变化的,什么叫容易变化的,就是说这个变量容易被其他的程序或者代理所影响,他的值受多方影响,容易变化. 编译器有着不同的优化策略,由于他的优化,可能产生一些不是我们预期的行为,这是什么意思呢? 举个例子 123val1 = x;//....与x无关代码val2 = x; 这里编译器一看,诶,程序中有两个地方使用了x ,而且看起来x 没有更新,那我就把x放到寄存器中,这样就不用再访问内存一次了. 可是问题就出在这 x 是容易变化的,很有可能被其他的代码或者硬件状态改变所改写,每次改写,x 在内存中的值就会变化,编译器这样一搞,行为肯定不对. 所以我们这时,将x 声明成volatile 于是编译器只会老老实实从内存中取值 声明volatile 声明变量格式 type volatile id 123int volatile data1;//这两种是一样的,volatile int data2; 表示id这个标识符所指的对象是易变得 声明指针 volatile type* id 12345volatile int iValue;//pointer to volatile variablevolatile int* piData = &amp;iValue; 特别注意 他是说这个指针所指的位置是易变的,而非这个指针是易变的,其实你仔细想想,如果说指针易变,那也应该是type * volatile id,当然我不知道有没有这个,你可以 试试 声明指向volatile的指针,他确实应该是要指向volatile的,否则UB(Undefined Behavior) 哪里用volatile 访问外围设备寄存器 中断ISR(Interrupt service routine)(理解成中断服务程序)或者signal handler 多线程共享 访问外围设备最为经典的是不是GPIO,或者访问硬盘,都是需要看硬件的状态寄存器啥的,这里的寄存器时刻变化着的,那肯定是volatile 的 1234567891011121314151617 volatile unsigned char FLAG_REG;void fun(void){// Repeat while bit 0 is setwhile (FLAG_REG &amp; 0x01){//Perform any operation}} 这里要不断的检查寄存器的第一位在访问磁盘的时候,也是同理,当然这里是查询的方式(指while循环) 中断服务程序12345678910111213141516171819202122232425262728293031323334volatile int giFlag = 0;ISR(void){ giFlag = 1;}int main(void){ while (!giFlag){ //do some work } return 0;}```当ISR 和程序共用一些全局变量的时候## 多线程```c//Global flag//volatile int gValue;void Task_1(void){gValue = 0;while (gValue == 0){sleep(1);}...}void Task_2(void){...gValue++;sleep(10);...} 当优化开启时 ,如果没有volatile 会产生什么后果,想一想 :) 死循环呗 const 和 volatile一起使用可以使用将const volatile一起用.看起来很邪恶…主要用于 访问有着固定地址的外围设备寄存器eg:unsigned int volatile * const pLcdReg = (unsigned int volatile *) 0x00020000;一个有着固定地址的指针,他所指的位置易变,嗯,很合理,你不允许改变这个指针(地址) 只读的eg:如果两个处理器使用共享内存位置相互通信，并且处理器仅使用该位置来读取数据，则必须使用const关键字将该位置设置为只读类型。123unsigned int const volatile gSharedFlag;unsigned char const volatile acSharedBuffer[BUFFER_SIZE]; 读取状态寄存器(其实和第一点一样)eg:123456789unsigned int const volatile * const pStatusFlagReg = (uint8_t *) 0x20000000;//to read status from the status registerREAD_DATA = * pStatusFlagReg;// Not possible because address qualify by const keyword*pStatusFlagReg = WRITE_DATA; 最后,你可以实验一下 123456789101112//file1.c#include &lt;stdio.h&gt;const volatile int cnt = 9;void print_cnt(){ printf(&quot;cnt.c=%d\\n&quot;, cnt);} 1234567891011121314//file2.c#include &lt;stdio.h&gt;extern int cnt;extern void print_cnt();int main(){ cnt=10; printf(&quot;cnt=%d\\n&quot;,cnt);} 然后gcc -O -g file1.c file2.c 最后执行一下,你可以看到是可以变的,当然我的设备实验了(window 下和 linux-wsl) 结束—– :)还有谁知道这个markdown 代码块怎么显示文件目录啊,烦死了","link":"/2021/12/19/keyword_volatile/"}],"tags":[{"name":"折腾","slug":"折腾","link":"/tags/%E6%8A%98%E8%85%BE/"},{"name":"c语言","slug":"c语言","link":"/tags/c%E8%AF%AD%E8%A8%80/"}],"categories":[]}